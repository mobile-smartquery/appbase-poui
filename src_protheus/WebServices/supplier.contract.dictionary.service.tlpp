#include 'tlpp-core.th'

#DEFINE ERRO_HTTP 400

namespace tdi.sigacom.supplier.dictionary
using namespace totvs.protheus.backoffice.reconciliation.util
using namespace tdi.sigacom.supplier.errorhandler


/*/{Protheus.doc} DictionaryService
  WS para centralizar as chamadas de dicionário de dados do Protheus

  @author Tiago Cunha
  @since 10/04/2025
  @version 1.0.0
/*/
class DictionaryService

	public data oAdapterBase as Object
	public data aFields     as array

	public method new() constructor
	public method getStruct()
	public method getData()
	public method getVirtualFields()
	public method getViewDefData()
	public method postViewDefData()
	public method postTrigger()

endClass

method new() class DictionaryService
	Self:oAdapterBase := FWAdapterBaseV2():new("GET", .T.)
return self


method getStruct(aStruct as array, aInfo as array, lBrowse as logical, cTableAlias as character, aTableRelation as array) class DictionaryService
	local nX := 0

	getStructByResponse(aStruct, @aInfo, lBrowse)

	for nX := 1 to Len(aTableRelation)
		if (!empty(aTableRelation[nX]))
			getStructByResponse(FWSX3Util():getListFieldsStruct(aTableRelation[nX], .T.), @aInfo, lBrowse)
		endif
	next nX

	jStruct := JsonObject():New()
	jStruct['struct']      := aInfo
	jStruct['description'] := allTrim(FWSX2Util():getX2Name(cTableAlias))
	jStruct['folders']     := getSXAJson(cTableAlias, 1)
	jStruct['agrups']      := getSXAJson(cTableAlias, 2) // agrupamentos (separadores)
return jStruct

static function getOptions(field as character, options as character) as array
	local info       as json // objeto JSON para informações gerais (campos, registros etc)
	local newOptions as array // array de JSON com a lista de opções e seus valores
	local aux        as array // array auxiliar para as options
	local option     as array // opção quebrada entre ID e DESCRIPTION
	local index      as numeric // controle do FOR

	newOptions := {}

	// verificar se possui opções
	if (!empty(options))

		If Upper(allTrim(field)) == "A1_PESSOA"
			options += ";E=Estrangeiro"
		Endif

		// verificar se é uma função que será macroexecutada
		if (at('#', options) > 0)
			options := allTrim(&(strTran(options, '#', '')))
		endIf

		// quebrar a lista de opções pelo separador ";"
		aux := strTokArr2(options, ';')

		// percorrer lista e criar array de opções
		for index := 01 to len(aux)
			// quebrar o ID e o DESCRIPTION
			option := strTokArr2(allTrim(aux[index]), '=')
			// verifica a quebra
			if (len(option) == 02)
				// adicionar no objeto
				info                := JsonObject():new()
				info['value']          := allTrim(option[01])
				info['label'] := allTrim(option[02])
				// adicionar no array
				aAdd(newOptions, info)
			endIf
		next index
	endIf
return newOptions

Static Function getStructByResponse(aStruct as array, aInfo as array, lBrowse as logical)
	local cDescription 	as character // descrição do campo
	local cOrder       	as character // ordem do campo
	local nIndex       	as numeric // controle de FOR
	local nCount  		as numeric // contador de registros

	// verifica se encontrou
	if (len(aStruct) > 0)
		// inicializa a ordem
		cOrder := replicate('0', 02)

		// percorre os campos para adicionar na estrutura
		nCount := len(aStruct)

		for nIndex := 01 to nCount
			// incrementa a ordem
			cOrder := soma1(cOrder)

			// remove espaços em branco
			aStruct[nIndex, 01] := allTrim(aStruct[nIndex, 01])

			// verifica se esta no modo de browse. também não podemos retornar campos virtuais, mesmo que esteja marcado como browse
			if lBrowse .And. (allTrim(getSX3Cache(aStruct[nIndex, 01], 'X3_BROWSE')) == 'N')
				loop
			EndIf

			// cria objeto com os dados do campo
			aAdd(aInfo,JsonObject():new())

			// recupera a descrição do campo
			cDescription := FWSX3Util():getDescription(aStruct[nIndex, 01])

			aInfo[Len(aInfo)]['from_sx3']       := .T.
			aInfo[Len(aInfo)]['alias']          := getSX3Cache(aStruct[nIndex, 01], 'X3_ARQUIVO') // ordem do campo
			aInfo[Len(aInfo)]['order']          := getSX3Cache(aStruct[nIndex, 01], 'X3_ORDEM') // ordem do campo
			aInfo[Len(aInfo)]['field']          := allTrim(aStruct[nIndex, 01]) // id do campo
			aInfo[Len(aInfo)]['title']          := allTrim(getSX3Cache(aStruct[nIndex, 01], 'X3_TITULO')) // título do campo
			aInfo[Len(aInfo)]['size']           := aStruct[nIndex, 03] // tamanho do campo
			aInfo[Len(aInfo)]['decimals']       := aStruct[nIndex, 04] // decimais do campo
			aInfo[Len(aInfo)]['type']           := aStruct[nIndex, 02] // tipo do campo
			aInfo[Len(aInfo)]['mask']           := allTrim(getSX3Cache(aStruct[nIndex, 01], 'X3_PICTURE')) // picture/mask do campo
			aInfo[Len(aInfo)]['dynamic_mask']   := allTrim(getSX3Cache(aStruct[nIndex, 01], 'X3_PICTVAR')) // picture/mask variável do campo
			aInfo[Len(aInfo)]['standard_query']        := allTrim(getSX3Cache(aStruct[nIndex, 01], 'X3_F3')) // consulta padrão
			aInfo[Len(aInfo)]['standard_query_detail'] := IIF(!Empty(aInfo[Len(aInfo)]['standard_query']), getStandardQuery(aInfo[Len(aInfo)]['standard_query']), Nil)
			aInfo[Len(aInfo)]['options']        := getOptions(aStruct[nIndex, 01], allTrim(getSX3Cache(aStruct[nIndex, 01], 'X3_CBOX'))) // lista de opções
			aInfo[Len(aInfo)]['virtual']        := getSX3Cache(aStruct[nIndex, 01], 'X3_CONTEXT') == 'V' // verifica se o campo é virtual
			aInfo[Len(aInfo)]['help']                  := allTrim((aStruct[nIndex, 01] + ": " + GetHlpSoluc(aStruct[nIndex, 01])[1]))

			if !lBrowse
				aInfo[Len(aInfo)]['required']       := X3Obrigat(aStruct[nIndex, 01]) // campo obrigatório
				aInfo[Len(aInfo)]['validation']     := allTrim(getSX3Cache(aStruct[nIndex, 01], 'X3_VALID')) // validação do campo
				aInfo[Len(aInfo)]['level']          := getSX3Cache(aStruct[nIndex, 01], 'X3_NIVEL') // nível de acesso
				aInfo[Len(aInfo)]['enabled']        := X3Uso(getSX3Cache(aStruct[nIndex, 01], 'X3_USADO')) // campo habilitado/usado?
				aInfo[Len(aInfo)]['description']           := noAcento(allTrim(cDescription)) // descrição do campo
				aInfo[Len(aInfo)]['browse']                := IIF(getSX3Cache(aStruct[nIndex, 01], 'X3_BROWSE') == "S", .T., .F.)
				aInfo[Len(aInfo)]['exist_trigger']         := ExistTrigger(aStruct[nIndex, 01])
				aInfo[Len(aInfo)]['folder']                := AllTrim(GetSx3Cache(aStruct[nIndex, 01],"X3_FOLDER"))
				aInfo[Len(aInfo)]['agrup']								 := AllTrim(GetSx3Cache(aStruct[nIndex, 01],"X3_AGRUP"))
				aInfo[Len(aInfo)]['editable']              := GetSx3Cache(aStruct[nIndex, 01], "X3_VISUAL") <> 'V'
				aInfo[Len(aInfo)]['relacao']							 := AllTrim(GetSx3Cache(aStruct[nIndex, 01],"X3_RELACAO"))
			endif

			// caso seja campo virtual, devemos recuperar o inicializador de browse
			if (aInfo[Len(aInfo)]['virtual'])
				aInfo[Len(aInfo)]['default'] := allTrim(getSX3Cache(aStruct[nIndex, 01], 'X3_INIBRW'))
			else
				aInfo[Len(aInfo)]['default'] := ''
			endIf

		next nIndex
	Else
		SetRestFault(ERRO_HTTP,  'alias "' + cTableAlias + '" inexistente')
	Endif
Return


// pega os folders do alias caso possua (SXA)
// nOpc = 1 - Pastas 2 - Agrupamentos (separadores)
Static Function getSXAJson(cAlias, nOpc)
	Local aFolders := {}

	SXA->(dbSetOrder( 1 ))
	If SXA->(dbSeek(cAlias))
		// pega os folders do alias caso possua (SXA)
		while SXA->(!Eof()) .and. SXA->(XA_ALIAS) == cAlias

			// irá adicionar apenas pastas não agrupamentos.
			// Caso seja pasta
			if empty(SXA->XA_TIPO) .and. nOpc == 1
				oJFolder := JsonObject():new()
				oJFolder['id']          := allTrim(SXA->XA_ORDEM)
				oJFolder['title']       := allTrim(XADescric())
				oJFolder['order']       := allTrim(SXA->XA_ORDEM)

				aAdd(aFolders, oJFolder)
			elseif SXA->XA_TIPO == "2" .and. nOpc == 2
				// Caso seja agrupamento (separador)
				oJFolder := JsonObject():new()
				oJFolder['id']          := allTrim(SXA->XA_AGRUP)
				oJFolder['title']       := allTrim(XADescric())
				oJFolder['order']       := allTrim(SXA->XA_ORDEM)

				aAdd(aFolders, oJFolder)

			endIf
			SXA->(dbSkip())
		EndDo
	endif

Return aFolders

Static Function getStandardQuery(cCodConPad)
	aSave      := SXB->(GetArea())
	cFields		 := ""
	JColumns   := JsonObject():new()
	cCodConPad := PadR(cCodConPad,6)

	JColumns['columns']          := {}
	JColumns['get_column_value'] := ""
	JColumns['lookup']            := ""

	SXB->(dbSetOrder(1))
	if SXB->(dbSeek(cCodConPad+"4"))
		cGetField := separa(CRMA910F3(cCodConPad), "+")[1]

		if "->" $ cGetField
			cGetField := separa(cGetField, "->")[2]
		endif

		JColumns['get_column_value'] := cGetField

		While SXB->(!Eof()) .And. SXB->(XB_ALIAS+XB_TIPO) == cCodConPad+"4"

			cContem := AllTrim(SXB->XB_CONTEM)

			if "->" $ cContem
				cContem := separa(cContem, "->")[2]
			endif

			if !(AllTrim(cContem) $ cFields)
				cFields += AllTrim(cContem)
				JColumn := JsonObject():new()
				JColumn['field'] := lower(AllTrim(cContem))
				JColumn['title'] := AllTrim(SXB->XB_DESCRI)
				aAdd(JColumns['columns'], JColumn)

				if empty(JColumns['lookup'])
					JColumns['lookup'] := getSX3Cache(cContem, 'X3_ARQUIVO')
				endif
			endif

			SXB->(dbSkip())
		EndDo
	endIf

	if JColumns['lookup'] == ""
		return Nil
	endif

	RestArea(aSave)
Return JColumns


method GetData(nPage As Numeric, nPageSize As Numeric, cTable as character, cFilter as character, cAdvancedFilter as character, cOrder as character) class DictionaryService

	Local aArea      as array
	Local cWhere     as character
	Local aUrlFilter as array
	local nX         as numeric

	aArea       := FwGetArea()
	aUrlFilter  := {}
	nX 				  := 0

	Self:oAdapterBase:setPage(nPage)
	Self:oAdapterBase:setPageSize(nPageSize)

	AddMapFields(self, cTable)
	Self:oAdapterBase:SetQuery( GetQuery(cTable) )

	// cWhere := " " + cTable + ".R_E_C_N_O_ > 0 "
	// Pega o primeiro campo do alias para a cláusula where que é a filial
	aStructTable := &(cTable)->(dbStruct())
	cFieldFil    := aStructTable[1][1]

	if "_FILIAL" $ cFieldFil
		cWhere := " " + cTable + "." + cFieldFil + " = '" + xFilial(cTable) + "' AND "
	endif

	cWhere += " " + cTable + ".D_E_L_E_T_ = ' ' "
	Self:oAdapterBase:SetWhere( cWhere )

	cUrlFilter := ""
	if !Empty(cFilter) .And. len(Self:aFields) > 0
		// cUrlFilter += ""
		for nX := 1 to len(Self:aFields)
			if nx == 1
				cUrlFilter += " contains(tolower(" + Self:aFields[nX][2] + "), '"+cFilter+"')"
			else
				cUrlFilter += " or contains(tolower(" + Self:aFields[nX][2] + "), '"+cFilter+"')"
			endif
		next

		aUrlFilter := {;
			{"FILTER", lower(cUrlFilter)};
			}
		self:oAdapterBase:SetUrlFilter(aUrlFilter)
	elseif !Empty(cAdvancedFilter) // filtros avançados
		aUrlFilter := {;
			{"FILTER", lower(cAdvancedFilter)};
			}
		self:oAdapterBase:SetUrlFilter(aUrlFilter)
	endif


	if !Empty(cOrder)
		Self:oAdapterBase:SetOrder(Upper(cOrder))
	else
		Self:oAdapterBase:SetOrderQuery(SqlOrder( (cTable)->(IndexKey(1))))
	endif

	If Self:oAdapterBase:Execute()
		Self:oAdapterBase:FillGetResponse()
	EndIf

	FwrestArea(aArea)
return


Static Function AddMapFields( oSelf As Object, cTable As Character )
	Local nI := 1
	Local cField    := "" as character
	Local aAllFields:= FWSX3Util():GetAllFields(cTable, .F.) as array
	Local aFieldSX3 := {} as Array
	Local aStruct   := {} as Array
	Local cTitulo   := "" as character

	For nI := 1 To Len(aAllFields)
		cField  := aAllFields[nI]
		aStruct := FWSX3Util():GetFieldStruct(cField, .F.)

		cTitulo := AllTrim(FWX3Titulo(cField))

		if GetSx3Cache(cField, "X3_BROWSE") == "S" .Or. cField $ "_FILIAL"
			aAdd(aFieldSX3,{GetSx3Cache(cField, "X3_ORDEM"),;
				AllTrim(Upper(cField)),;
				AllTrim(If(Empty(cTitulo), Upper(cField), cTitulo)),;
				aStruct[2],;
				aStruct[3],;
				aStruct[4],;
				AllTrim(X3Picture(cField)),""})

		endif
	Next


	For nI := 1 To Len(aFieldSX3)
		cField := Upper(aFieldSX3[nI][2])
		oSelf:oAdapterBase:addMapFields(cField, cField, .T., .F., {cField, aFieldSX3[nI][4], aFieldSX3[nI][5], aFieldSX3[nI][6]}, cField)
	Next nI

	oSelf:aFields := aFieldSX3

	// Adiciona o Recno
	oSelf:oAdapterBase:AddMapFields("recno", 'R_E_C_N_O_',.T.,.T.,{'R_E_C_N_O_', 'N', ,0})

Return

Static Function GetQuery(cTable as character)
	Local cQuery AS CHARACTER

	cQuery := " SELECT #QueryFields#"
	cQuery += " FROM " + RetSqlName( cTable ) + " " + cTable
	cQuery += " WHERE #QueryWhere#"

Return cQuery


/*/{Protheus.doc} getVirtualFields
  Método para retornar os campos virtuais de um alias.

  @author Tiago Cunha
  @since 15/04/2025
  @version 1.0.0
/*/
method getVirtualFields(cTableAlias as character, lBrowse as logical) class DictionaryService
	local aStruct as array
	local nIndex  as numeric
	local aVirtualFields as array

	default lBrowse := .F.

	aVirtualFields := {}

	aStruct := FWSX3Util():getListFieldsStruct(cTableAlias, .T.)

	for nIndex := 1 to len(aStruct)
		if lBrowse .And. allTrim(getSX3Cache(aStruct[nIndex, 01], 'X3_BROWSE')) == 'N'
			loop
		EndIf

		if (getSX3Cache(aStruct[nIndex, 01], 'X3_CONTEXT') == 'V')
			aAdd(aVirtualFields, allTrim(aStruct[nIndex, 01]))
		endif
	next
return aVirtualFields


method getViewDefData(cTableAlias as character, jItemData as json) class DictionaryService
	local cQuerySX3    := ""
	local cAliasSX3    := getNextAlias()
	local cQryTable	   := getNextAlias()
	local cAliasTable	 := getNextAlias()
	local cFieldsSX3   := ""
	local aFieldsSX3   := {}
	local JResposta    := JsonObject():new()
	local nX 				   := 0
	local nRecnoAlias  := 0
	local nY 				   := 0
	local aVirtualFields     := {}
	local nSaveSx8 := GetSX8Len() as numeric

	aVirtualFields := ::getVirtualFields(cTableAlias, .T.)

	// Pega os campos das tabelas informadas
	cQuerySX3 := "SELECT X3_CAMPO, X3_TIPO FROM " + RetSQLName("SX3") + " WHERE X3_ARQUIVO = '" + cTableAlias + "' AND X3_CONTEXT != 'V' AND D_E_L_E_T_  = ' '"
	dbUseArea( .T., "TOPCONN", TcGenQry(,,cQuerySX3), cAliasSX3, .F., .T. )

	While !(cAliasSX3)->(Eof())

		if (cAliasSX3)->X3_TIPO == "M"
			aAdd(aVirtualFields, AllTrim((cAliasSX3)->X3_CAMPO))
		else
			aAdd(aFieldsSX3, AllTrim((cAliasSX3)->X3_CAMPO))
			cFieldsSX3 += AllTrim((cAliasSX3)->X3_CAMPO) + ', '
		endif
		(cAliasSX3)->(dbSkip())
	EndDo
	(cAliasSX3)->(dbCloseArea())

	// Remove a última vírgula
	cFieldsSX3 := alltrim(substr(cFieldsSX3, 1, len(cFieldsSX3) - 2))

	nRecnoAlias := JItemData["item"]:getJsonText("RECNO")


	// Monta a query
	cQryTable := "SELECT R_E_C_N_O_ AS RECNO, " + cFieldsSX3 + " FROM " + RetSQLName(cTableAlias) + " WHERE R_E_C_N_O_ = " + nRecnoAlias + " AND D_E_L_E_T_ = ' '"
	dbUseArea( .T., "TOPCONN", TcGenQry(,,cQryTable), cAliasTable, .F., .T. )

	While !(cAliasTable)->(Eof())
		// Adiciona o _recno
		JResposta['RECNO'] := (cAliasTable)->(RECNO)

		for nX := 1 to len(aFieldsSX3)
			if GetSx3CaChe(aFieldsSX3[nX], "X3_TIPO" ) == 'C'
				JResposta[alltrim(aFieldsSX3[nX])] := alltrim((cAliasTable)->&(aFieldsSX3[nX]))
			else
				JResposta[alltrim(aFieldsSX3[nX])] := (cAliasTable)->&(aFieldsSX3[nX])
			endif
		next nX

		if len(aVirtualFields) > 0
			(cTableAlias)->(DbGoTo(Val(nRecnoAlias)))
			RegToMemory(cTableAlias,.F.,.T.)
			// pecorre os campos virtuais e atribui o valor do campo virtual no item
			for nY := 1 to len(aVirtualFields)
				if GetSx3CaChe(Upper(aVirtualFields[nY]), "X3_TIPO" ) == 'C'
					JResposta[Upper(aVirtualFields[nY])] := AllTrim(M->&(aVirtualFields[nY]))
				else
					JResposta[Upper(aVirtualFields[nY])] := M->&(aVirtualFields[nY])
				endIf
			next
		endIF

		(cAliasTable)->(dbSkip())
	EndDo
	(cAliasTable)->(dbCloseArea())

	While (GetSX8Len() > nSaveSx8)
		RollBackSx8()
	End

Return JResposta


method postViewDefData(cTableAlias as character, jItemData as json) class DictionaryService

return JsonObject():new()


method postTrigger(cCampo as character, JBody as json) class DictionaryService
	local jResponse := JsonObject():new() as Json
	local nX := 0 as numeric
	local nY := 0 as numeric
	local cAlias := "" as character
	local nSaveSx8 := GetSX8Len() as numeric

	// Pega o alias do campo informado
	cAlias := GetSx3Cache(cCampo, 'X3_ARQUIVO')

	// Verifica se o alias existe
	if ValType(cAlias) == 'U'
		oError:description := 'Alias "' + cAlias + '" não encontrado.'
		oError:errorstack  := 'Alias "' + cAlias + '" não encontrado.'
		Throw oError
	endif

	// Carrega a temporária (M) do alias
	RegToMemory(cAlias,.T., .T.)
	// Preenche a temporária (M) com os dados do body
	for nX := 1 to len(jBody:GetNames())
		M->&(jBody:GetNames()[nX]) := jBody:GetJsonText(jBody:GetNames()[nX])
	next

	// Executa o gatilho
	If ExistTrigger(cCampo)
		RunTrigger( ;
			1,;           //nTipo (1=Enchoice; 2=GetDados; 3=F3)
		Nil,;         //Linha atual da Grid quando for tipo 2
		Nil,;         //Não utilizado
		,;            //Objeto quando for tipo 1
		cCampo;       //Campo que dispara o gatilho
		)
	EndIf

	// Pecorre a estrutura do alias montando o novo objeto de resposta com os dados atualizados
	jResponse := JsonObject():new()
	aStruct   := aStruct := FWSX3Util():getListFieldsStruct(cAlias, .T.)

	for nY := 1 to len(aStruct)
		// Pula a filial pois é um campo ignorado pelo front
		if '_FILIAL' $ aStruct[nY, 01]
			loop
		endif

		jResponse[aStruct[nY, 01]] := AllTrim(M->&(aStruct[nY, 01]))
	next

	While (GetSX8Len() > nSaveSx8)
		RollBackSx8()
	End
return jResponse