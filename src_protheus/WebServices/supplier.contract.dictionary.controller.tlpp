#include 'tlpp-core.th'

#DEFINE ERRO_HTTP 400

namespace tdi.sigacom.supplier.dictionary
using namespace totvs.protheus.backoffice.reconciliation.util
using namespace tdi.sigacom.supplier.errorhandler


/*/{Protheus.doc} DictionaryController
  WS para centralizar as chamadas de dicionário de dados do Protheus

  @author Tiago Cunha
  @since 10/04/2025
  @version 1.0.0
/*/
class DictionaryController

	public method new() constructor

	@get('/api/tdi/com/supplier/dictionary/browse/columns/:ctabela')
	public method getBrowseColumns()

	@get('/api/tdi/com/supplier/dictionary/browse/items/:ctabela')
	public method getBrowseItems()

	@get('/api/tdi/com/supplier/dictionary/struct/:ctabela')
	public method getStruct()

	@get('/api/tdi/com/supplier/dictionary/data/:calias/:citemdata')
	public method getDictionaryData()

	@get('/api/tdi/com/supplier/dictionary/initializer/:calias')
	public method getDefaultInitializer()

	@post('/api/tdi/com/supplier/dictionary/trigger/:ccampo')
	public method postTrigger()


endClass


method new() class DictionaryController
return self

/*/{Protheus.doc} getBrowseColumns
  Método para pegar as colunas do browse de um alias para o front montar o browse

  @author Tiago Cunha
  @since 15/04/2025
  @version 1.0.0
/*/
method getBrowseColumns() class DictionaryController
	local JStruct        as json
	local JResponse      as json
	local oError 			   as object
	local oErrorHandler	 as object

	try
		tcGetHeaders()

		oError			   := ErrorClass():New()
		JStruct        := ::getStruct(oRest, .T.)
		JResponse			 := JsonObject():new()

		// Verifica se o JStruct é um objeto JSON
		if ValType(JStruct) == "J"
			oRest:setKeyHeaderResponse('Content-Type','application/json')
			JResponse['struct'] := JStruct:GetJsonObject("struct")

			oRest:setResponse(JResponse:toJson())
		else
			oError:description := 'Alias informado não existe.'
			oError:errorstack  := 'Alias informado não existe.'
			Throw oError
		endif

	Catch error
		cError                 := error:errorstack
		oErrorHandler          := ErrorHandler():new()
		oErrorHandler:cCode    := 'request_error'
		oErrorHandler:cMessage := 'Erro ao processar a requisição.'

		oErrorHandler:addDetail(oErrorHandler:cCode, error:description, cError)

		oRest:setKeyHeaderResponse('Content-Type','application/json')
		oRest:setFault(oErrorHandler:getJSON())
		FreeObj(oErrorHandler)
	endtry
return Nil

/*/{Protheus.doc} getBrowseItems
  Método para pegar os items do browse de um alias

  @author Tiago Cunha
  @since 15/04/2025
	@param cId - ID do item a ser buscado (opcional)
  @version 1.0.0
/*/
method getBrowseItems(cId) class DictionaryController
	local oError 			    as object
	local oErrorHandler	  as object
	local oService    	  as object
	local nPage           as numeric
	local nPageSize       as numeric
	local cFilter         as character
	local aIndex          as array
	local aAuxIndexs      as array
	local aVirtualFields  as array
	local lResponse       as logical
	local cChaveRes       as character
	local cResponse       as character
	local jPath           as Json
	local jResposta       as Json
	local cTableAlias     as character
	local nX              as numeric
	local nY              as numeric

	default cId           := ''

	try
		oError			   := ErrorClass():New()
		oService		   := DictionaryService():new()
		nPage          := 1
		nPageSize      := 10
		cFilter        := ''
		cAdvanced      := ''
		cOrder         := ''
		jResposta	 		 := JsonObject():new()
		aIndex         := {}
		aAuxIndexs     := {}
		aVirtualFields := {}
		lResponse      := .F.
		nX             := 0
		nY             := 0
		cChaveRes      := "message"
		cResponse      := "Resposta inválida."
		jPath          := oRest:getPathParamsRequest()
		cTableAlias    := Upper(jPath['ctabela'])
		oError			   := ErrorClass():New()
		nSaveSx8			 := GetSX8Len()

		// tenta recuperar a partir da SX3
		aStruct := FWSX3Util():getListFieldsStruct(cTableAlias, .T.)

		// caso contrário pega a estrutura da temporária
		if (len(aStruct) == 0 .AND. select(cTableAlias) > 0)
			aStruct := (cTableAlias)->(dbStruct())
		endIf

		// verifica se encontrou
		if (len(aStruct) > 0)
			tcGetHeaders()
			tcGetPageAndPageSize(@nPage, @nPageSize)

			// pegando o filtro
			If (oRest:getQueryRequest():GetJsonText("filter") != "null")
				cFilter := AllTrim(oRest:getQueryRequest():GetJsonText("filter"))
			EndIf

			// pegando o filtro avançado
			If (oRest:getQueryRequest():GetJsonText("$advanced") != "null")
				cAdvanced := AllTrim(oRest:getQueryRequest():GetJsonText("$advanced"))
			EndIf

			// pegando o filtro avançado
			If (oRest:getQueryRequest():GetJsonText("$order") != "null")
				cOrder := AllTrim(oRest:getQueryRequest():GetJsonText("$order"))
			EndIf

			oService:GetData(nPage, nPageSize, cTableAlias, cFilter, cAdvanced, cOrder)

			if oService:oAdapterBase:lOk
				jResponse := oService:oAdapterBase:getJSONResponse()
			else
				oError:description := 'Não foi possível recuperar os dados.'
				oError:errorstack  := 'Não foi possível recuperar os dados: ' + oService:oAdapterBase:getMessage()
				Throw oError
			endIf

			jResposta:fromJson(jResponse)
			If ValType(jResposta:GetJsonObject("items")) <> "U"

				// TRATAMENTO PARA OBTENÇÂO DOS DADOS DE CAMPOS VIRTUAIS MARCADOS PARA USAR NO BROWSE
				// retorna um array com os campos virtuais do alias
				aVirtualFields := oService:getVirtualFields(cTableAlias, .T.)
				// jResposta['virtualFields'] := aVirtualFields
				// verifica se o alias possui campos virtuais
				aItems := jResposta:GetJsonObject("items")
				if len(aVirtualFields) > 0 .And. len(aItems) > 0
					// pecorre os items se posicionando utilizando o recno
					for nx := 1 to len(aItems)
						(cTableAlias)->(DbGoTo(aItems[nX]:GetJsonObject("recno")))
						RegToMemory(cTableAlias,.F.,.T.)
						// pecorre os campos virtuais e atribui o valor do campo virtual no item
						for nY := 1 to len(aVirtualFields)
							aItems[nX][lower(aVirtualFields[nY])] := AllTrim(M->&(aVirtualFields[nY]))
						next
					next
				endif

						// Voltando a numeração pois ela será posteriormente tratada pelo commit
				While (GetSX8Len() > nSaveSx8)
					RollBackSx8()
				End

				tcAnswerRest(jResposta, .T.)
			Else
				oError:description := 'Não foi possível recuperar os dados.'
				oError:errorstack  := 'Não foi possível recuperar os dados.'
				Throw oError
			endIf

			oService:oAdapterBase:DeActivate()
			FreeObj(oService)
		else
			oError:description := 'alias "' + cTableAlias + '" inexistente'
			oError:errorstack  := 'alias "' + cTableAlias + '" inexistente'
			Throw oError
		endIf

	Catch error
		cError                 := error:errorstack
		oErrorHandler          := ErrorHandler():new()
		oErrorHandler:cCode    := 'request_error'
		oErrorHandler:cMessage := 'Erro ao processar a requisição.'

		oErrorHandler:addDetail(oErrorHandler:cCode, error:description, cError)

		oRest:setKeyHeaderResponse('Content-Type','application/json')
		oRest:setFault(oErrorHandler:getJSON())
		FreeObj(oErrorHandler)
	endtry

return Nil


method getStruct(oRestx as object, lBrowse as logical) class DictionaryController
	local aInfo          as array // informações do campo
	local aStruct        as array // estrutura dos campos
	local jPath          as json
	local cTableAlias    as character
	local aTableRelation as array // tabela de relação
	local oError 			   as object
	local oErrorHandler	 as object
	local oService	     as object

	default oRestx       := oRest
	default lBrowse      := .F.

	Try
		tcGetHeaders()

		jPath          := oRestx:getPathParamsRequest()
		cTableAlias    := Upper(jPath['ctabela'])
		oError			   := ErrorClass():New()
		aTableRelation := {}
		aInfo          := {}

		// verifica se é um alias válido
		if (!empty(cTableAlias))
			// tenta recuperar a partir da SX3
			aStruct := FWSX3Util():getListFieldsStruct(cTableAlias, .T.)

			// caso contrário pega a estrutura da temporária
			if (len(aStruct) == 0 .AND. select(cTableAlias) > 0)
				aStruct := (cTableAlias)->(dbStruct())
			endIf

			// verifica se encontrou
			if (len(aStruct) > 0)

				oService  := DictionaryService():new()
				JResponse := oService:getStruct(aStruct, @aInfo, lBrowse, cTableAlias, @aTableRelation)

				if ValType(JResponse) <> 'J'
					oError:description := 'Não foi possivel obtar a estrutura do alias "' + cTableAlias + '"'
					oError:errorstack  := 'Não foi possivel obtar a estrutura do alias "' + cTableAlias + '"'
					Throw oError
				endif

				if lBrowse
					return JResponse
				else
					oRestx:setKeyHeaderResponse('Content-Type','application/json')
					oRestx:setResponse(JResponse:toJson())
				endif
			else
				oError:description := 'alias "' + cTableAlias + '" inexistente'
				oError:errorstack  := 'alias "' + cTableAlias + '" inexistente'
				Throw oError
			endIf
		else
			oError:description := 'alias "' + cTableAlias + '" inexistente'
			oError:errorstack  := 'alias "' + cTableAlias + '" inexistente'
			Throw oError
		endIf

		if (valType(aInfo) == 'J')
			freeObj(aInfo)
		endIf
	Catch error
		cError                 := error:errorstack
		oErrorHandler          := ErrorHandler():new()
		oErrorHandler:cCode    := 'request_error'
		oErrorHandler:cMessage := 'Erro ao processar a requisição.'

		oErrorHandler:addDetail(oErrorHandler:cCode, error:description, cError)

		oRestx:setKeyHeaderResponse('Content-Type','application/json')
		oRestx:setFault(oErrorHandler:getJSON())
		FreeObj(oErrorHandler)
	endtry

return Nil


method getDictionaryData() class DictionaryController
	local oError 			    as object
	local oErrorHandler	  as object
	local oService    	  as object
	local nPage           as numeric
	local nPageSize       as numeric
	local cFilter         as character
	local cAdvanced       as character
	local jPath           as Json
	local jResposta       as Json
	local cTableAlias     as character
	local cItemData       as character
	local JItemData      as Json

	try
		oError			   := ErrorClass():New()
		oService		   := DictionaryService():new()
		nPage          := 1
		nPageSize      := 10
		cFilter        := ''
		cAdvanced      := ''
		jResposta	 		 := JsonObject():new()
		JItemData	 		 := JsonObject():new()
		jPath          := oRest:getPathParamsRequest()
		cTableAlias    := jPath['calias']
		cItemData      := jPath['citemdata']
		oError			   := ErrorClass():New()

		tcGetHeaders()

		// Verifica se o itemData foi passado
		if Empty(cItemData) .or. cItemData == 'null'
			oError:description := 'Parâmetro "itemData" não informado ou inválido.'
			oError:errorstack  := 'Parâmetro "itemData" não informado ou inválido.'
			Throw oError
		endif

		JItemData:fromJson(cItemData)

		jResposta := oService:getViewDefData(cTableAlias, JItemData)

		// // Verifica se o JResposta é um objeto JSON que possui chave "items"
		// if len(jResposta:GetNames()) > 0

		// else
		// endif

		oRest:setKeyHeaderResponse('Content-Type','application/json')
		oRest:setResponse(jResposta:toJson())

	Catch error
		cError                 := error:errorstack
		oErrorHandler          := ErrorHandler():new()
		oErrorHandler:cCode    := 'request_error'
		oErrorHandler:cMessage := 'Erro ao processar a requisição.'

		oErrorHandler:addDetail(oErrorHandler:cCode, error:description, cError)

		oRest:setKeyHeaderResponse('Content-Type','application/json')
		oRest:setFault(oErrorHandler:getJSON())
		FreeObj(oErrorHandler)
	endtry
return Nil


method getDefaultInitializer() class DictionaryController
	local oError 			    as object
	local oErrorHandler	  as object
	local jPath           as Json
	local jResponse       as Json
	local jBody           as Json
	local cBody           as character
	local cAlias          as character
	local nX 						  as numeric
	local nY 						  as numeric
	local nSaveSx8	      as numeric

	try
		oError			   := ErrorClass():New()
		jResponse      := JsonObject():new()
		JItemData	 		 := JsonObject():new()
		jPath          := oRest:getPathParamsRequest()
		cAlias         := jPath['calias']
		cBody	         := oRest:getBodyRequest()
		oError			   := ErrorClass():New()
		nX 					   := 0
		nY 					   := 0
		nSaveSx8			 := GetSX8Len()

		tcGetHeaders()

		if ValType(cBody) == 'U'
			oError:description := 'Body de contexto não informado.'
			oError:errorstack  := 'Body de contexto não informado.'
			Throw oError
		endif

		// Pega o alias do campo informado
		aStruct := FWSX3Util():getListFieldsStruct(cAlias, .T.)

		// Verifica se o alias existe
		if len(aStruct) == 0
			oError:description := 'Alias "' + cAlias + '" não encontrado.'
			oError:errorstack  := 'Alias "' + cAlias + '" não encontrado.'
			Throw oError
		endif

		//  Transforma o body em um objeto JSON
		jBody := JsonObject():new()
		jBody:fromJson(cBody)

		// Carrega a temporária (M) do alias
		RegToMemory(cAlias,.T., .T.)

		// Pecorre a estrutura do alias montando o novo objeto de resposta com os dados atualizados
		for nY := 1 to len(aStruct)
			// Pula a filial pois é um campo ignorado pelo front
			if '_FILIAL' $ aStruct[nY, 01]
				loop
			endif

			jResponse[aStruct[nY, 01]] := AllTrim(M->&(aStruct[nY, 01]))
		next

		// Voltando a numeração pois ela será posteriormente tratada pelo commit
		While (GetSX8Len() > nSaveSx8)
			RollBackSx8()
		End

		oRest:setKeyHeaderResponse('Content-Type','application/json')
		oRest:setResponse(jResponse:toJson())

	Catch error
		cError                 := error:errorstack
		oErrorHandler          := ErrorHandler():new()
		oErrorHandler:cCode    := 'request_error'
		oErrorHandler:cMessage := 'Erro ao processar a requisição.'

		oErrorHandler:addDetail(oErrorHandler:cCode, error:description, cError)

		oRest:setKeyHeaderResponse('Content-Type','application/json')
		oRest:setFault(oErrorHandler:getJSON())
		FreeObj(oErrorHandler)
	endtry
return Nil


method postTrigger() class DictionaryController
	local oError 			    as object
	local oErrorHandler	  as object
	local oService    	  as object
	local jPath           as Json
	local JResponse       as Json
	local jBody           as Json
	local cBody	          as character
	local cCampo 			    as character

	try
		oError			   := ErrorClass():New()
		oService		   := DictionaryService():new()
		JResponse	 		 := JsonObject():new()
		jBody	 		     := JsonObject():new()
		jPath          := oRest:getPathParamsRequest()
		cBody					 := oRest:getBodyRequest()
		cCampo			   := jPath['ccampo']

		tcGetHeaders()

		// Verifica se o campo do gatilho foi passado
		if Empty(cCampo) .or. cCampo == 'null'
			oError:description := 'Header "Trigger-Field" não informado ou inválido.'
			oError:errorstack  := 'Header "Trigger-Field" não informado ou inválido.'
			Throw oError
		endif

		if ValType(cBody) == 'U'
			oError:description := 'Body de contexto não informado.'
			oError:errorstack  := 'Body de contexto não informado.'
			Throw oError
		endif

		// Verifica se o gatilho existe para o campo informado
		if !ExistTrigger(cCampo)
			oError:description := 'Gatilho não encontrado para o campo "' + cCampo + '".'
			oError:errorstack  := 'Gatilho não encontrado para o campo "' + cCampo + '".'
			Throw oError
		endif

		JBody:fromJson(cBody)

		JResponse := oService:postTrigger(cCampo, JBody)

		oRest:setKeyHeaderResponse('Content-Type','application/json')
		oRest:setResponse(JResponse:toJson())

	Catch error
		cError                 := error:errorstack
		oErrorHandler          := ErrorHandler():new()
		oErrorHandler:cCode    := 'trigger_error'
		oErrorHandler:cMessage := 'Erro ao processar o gatilho.'

		oErrorHandler:addDetail(oErrorHandler:cCode, error:description, cError)

		oRest:setKeyHeaderResponse('Content-Type','application/json')
		oRest:setFault(oErrorHandler:getJSON())
		FreeObj(oErrorHandler)
	endtry
return Nil


// method postCommitDictionary() class Dicionario

// 	oRest:setKeyHeaderResponse('Content-Type','application/json')
// 	u_COMMITTABLEDATA(oRest)

// Return .T.

// method postTrigger() class Dicionario

// 	oRest:setKeyHeaderResponse('Content-Type','application/json')
// 	u_POSTTRIGGER(oRest)
// 	// setRestFault(ERRO_HTTP,  'inexistente')
// return .T.









// User Function COMMITTABLEDATA(oRest as object)
// 	// local jPath          := oRest:getPathParamsRequest()
// 	// local cTableAlias    := Upper(jPath['ctabela'])

// 	// 1 - ira verificar se foi passado um body
// 	// 3 - ira verificar se o alias existe na SX3, caso contrario ira retornar erro
// 	// 4 - Verificado irá verificar se todos os campos existem na SX3, se os campos obrigatórios estão preenchidos
// 	// 5 - Cria o MVC e inicia o preenchimento dos campos. ele só preenche campos reais e ignora os virtuais
// 	// 6 - Se um campo é opcional ele chama o iniciador padrão dele atribuindo o valor dele no campo.
// 	// Caso ocorra erro em algum dessas etapas irá retornar o erro
// 	SetRestFault(ERRO_HTTP,  'inexistente')
// Return




// User Function POSTTRIGGER(oRest as Object)
// 	Local JHeader as Json
// 	local oError 			  as object
// 	local oErrorHandler	as object
// 	local nX						as numeric
// 	local nY						as numeric

// 	Try
// 		tcGetHeaders()

// 		oError  := ErrorClass():New()
// 		JHeader := oRest:getHeaderRequest()
// 		nx 		  := 0
// 		nY 		  := 0

// 		// Verifica se foi passado o header de trigger (Trigger-Field)
// 		cField := JHeader:GetJsonText("trigger-field")
// 		cBody	 := oRest:getBodyRequest()

// 		// Verifica se o header do campo do gatilho foi passado
// 		if Empty(cField) .or. cField == 'null'
// 			oError:description := 'Header "Trigger-Field" não informado ou inválido.'
// 			oError:errorstack  := 'Header "Trigger-Field" não informado ou inválido.'
// 			Throw oError
// 		endif

// 		// Verifica se o body de contexto foi passado
// 		if ValType(cBody) == 'U'
// 			oError:description := 'Body de contexto não informado.'
// 			oError:errorstack  := 'Body de contexto não informado.'
// 			Throw oError
// 		endif

// 		// Verifica se o gatilho existe para o campo informado
// 		if !ExistTrigger(cField)
// 			oError:description := 'Gatilho não encontrado para o campo "' + cField + '".'
// 			oError:errorstack  := 'Gatilho não encontrado para o campo "' + cField + '".'
// 			Throw oError
// 		endif

// 		// Pega o alias do campo informado
// 		cAlias := GetSx3Cache(cField, 'X3_ARQUIVO')

// 		// Verifica se o alias existe
// 		if ValType(cAlias) == 'U'
// 			oError:description := 'Alias "' + cAlias + '" não encontrado.'
// 			oError:errorstack  := 'Alias "' + cAlias + '" não encontrado.'
// 			Throw oError
// 		endif

// 		//  Transforma o body em um objeto JSON
// 		jBody := JsonObject():new()
// 		jBody:fromJson(cBody)

// 		// Carrega a temporária (M) do alias
// 		RegToMemory(cAlias,.T., .F.)
// 		// Preenche a temporária (M) com os dados do body
// 		for nX := 1 to len(jBody:GetNames())
// 			M->&(jBody:GetNames()[nX]) := jBody:GetJsonText(jBody:GetNames()[nX])
// 		next

// 		// Executa o gatilho
// 		If ExistTrigger(cField)
// 			RunTrigger( ;
// 									1,;           //nTipo (1=Enchoice; 2=GetDados; 3=F3)
// 								Nil,;         //Linha atual da Grid quando for tipo 2
// 								Nil,;         //Não utilizado
// 								,;            //Objeto quando for tipo 1
// 								cField;       //Campo que dispara o gatilho
// 			)
// 		EndIf

// 		// Pecorre a estrutura do alias montando o novo objeto de resposta com os dados atualizados
// 		jResponse := JsonObject():new()
// 		aStruct   := (cAlias)->(dbStruct())

// 		for nY := 1 to len(aStruct)
// 			// Pula a filial pois é um campo ignorado pelo front
// 			if '_FILIAL' $ aStruct[nY, 01]
// 				loop
// 			endif

// 			jResponse[aStruct[nY, 01]] := AllTrim(M->&(aStruct[nY, 01]))
// 		next

// 		oRest:setKeyHeaderResponse('Content-Type','application/json')
// 		oRest:setResponse(jResponse:toJson())

// 	Catch error
// 		cError                 := error:errorstack
// 		oErrorHandler          := ErrorHandler():new()
// 		oErrorHandler:cCode    := 'trigger_error'
// 		oErrorHandler:cMessage := 'Erro ao processar o gatilho.'

// 		oErrorHandler:addDetail(oErrorHandler:cCode, error:description, cError)

// 		oRest:setKeyHeaderResponse('Content-Type','application/json')
// 		oRest:setFault(oErrorHandler:getJSON())
// 		FreeObj(oErrorHandler)
// 	endtry

// 	// ele ira verificar se o campo passado existe e se possui gatilho
// 	// caso possui irá seguir, caso não gera erro
// 	// ira verificar se foi passado um body
// 	// irá pegar o alias do campo informado e em seguida irá gerar a temporaria (M) do alias
// 	// irá peccorer o body verificando se o campo existe se existir preenche o M correspodente
// 	// tudo preenchido irá iniciar o processo de chamar o gatilho
// 	// caso ocorra erro em algum dessas etapas irá retornar o erro
// 	// gatilho chamado irá pecorrer a temporaria (M) e preencher o objeto de resposta com os dados atualizados
// 	// irá retornar o objeto de resposta com os dados atualizados para o front setar os novos dados.
// Return